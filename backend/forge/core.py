"""
THE FORGE Core Module

This module implements the core functionality of THE FORGE, the cosmic quantum
furnace that powers the entire blockchain architecture. It provides quantum
energy generation, monitoring, and distribution to all layers of the system.

Key components:
1. QuantumForge: The main quantum energy generator
2. QuantumLink: Connects THE FORGE to other components
3. EnergyMonitor: Monitors and manages energy distribution
"""

import hashlib
import json
import time
import uuid
import math
import random
from typing import Dict, List, Any, Optional, Union, Tuple
from enum import Enum, auto

# Import quantum security for enhanced entropy
from quantum_security import QuantumRandomNumberGenerator


class ForgeStatus(Enum):
    """Status of THE FORGE"""
    INITIALIZING = auto()  # Starting up
    ONLINE = auto()        # Fully operational
    CRITICAL = auto()      # Operating at critical levels
    RECHARGING = auto()    # Regenerating energy
    STABILIZING = auto()   # Stabilizing after fluctuation
    OFFLINE = auto()       # Not operational


class EnergyType(Enum):
    """Types of quantum energy generated by THE FORGE"""
    COMPUTATIONAL = auto()  # For blockchain operations
    CRYPTOGRAPHIC = auto()  # For security operations
    GENERATIVE = auto()     # For asset creation
    DIMENSIONAL = auto()    # For cross-chain links
    STABILIZING = auto()    # For system stability


class QuantumForge:
    """
    The quantum energy generation core of the blockchain architecture.
    
    Acts as the central power source and asset creation engine, generating
    quantum energy through cosmic entanglement and dimensional resonance.
    THE FORGE is the heart of the system, powering all operations across
    the three blockchain layers.
    """
    
    def __init__(self, 
                 initial_energy_capacity: float = 1000000.0,
                 forge_temperature: float = 100.0):
        """
        Initialize THE FORGE.
        
        Args:
            initial_energy_capacity: Initial energy capacity
            forge_temperature: Starting temperature in quantum units
        """
        self.forge_id = str(uuid.uuid4())
        self.energy_capacity = initial_energy_capacity
        self.current_energy = initial_energy_capacity * 0.75  # Start at 75%
        self.forge_temperature = forge_temperature
        self.stability = 100.0  # Percentage
        self.cosmic_resonance = 1.0  # Multiplier for energy generation
        self.quantum_fluctuation = 0.0  # Current fluctuation level
        self.status = ForgeStatus.INITIALIZING
        self.creation_time = time.time()
        self.last_cycle_time = self.creation_time
        self.cycle_count = 0
        self.energy_distribution = {}  # layer_id -> energy amount
        self.quantum_links = {}  # link_id -> QuantumLink
        self.energy_history = []  # [(timestamp, energy_level), ...]
        self.alerts = []
        self.qrng = QuantumRandomNumberGenerator()
        
        # Start THE FORGE
        self._initialize_forge()
    
    def _initialize_forge(self) -> None:
        """Initialize THE FORGE with starting parameters"""
        # Record initial energy level
        self.energy_history.append((time.time(), self.current_energy))
        
        # Set initial energy distribution (balanced across layers)
        self.energy_distribution = {
            "genesischain": 0.0,
            "nexuslayer": 0.0,
            "dreamchain": 0.0
        }
        
        # Simulate cosmic quantum fluctuations
        self.quantum_fluctuation = self.qrng.get_random_float() * 0.1
        
        # THE FORGE is now online
        self.status = ForgeStatus.ONLINE
    
    def generate_quantum_energy(self, cycles: int = 1) -> float:
        """
        Generate quantum energy through cosmic entanglement.
        
        Args:
            cycles: Number of generation cycles to run
            
        Returns:
            Amount of energy generated
        """
        total_energy_generated = 0.0
        
        for _ in range(cycles):
            # Calculate base energy from temperature
            base_energy = self.forge_temperature * 0.1
            
            # Apply cosmic resonance multiplier
            energy = base_energy * self.cosmic_resonance
            
            # Apply quantum fluctuation (can be positive or negative)
            fluctuation = (self.qrng.get_random_float() * 2 - 1) * 0.2
            energy *= (1 + fluctuation)
            
            # Update quantum fluctuation level
            self.quantum_fluctuation = fluctuation
            
            # Add generated energy
            total_energy_generated += max(0, energy)
            
            # Update forge state
            self.cycle_count += 1
            self._update_forge_state()
        
        # Add the generated energy to current level
        self.current_energy = min(self.energy_capacity, 
                                 self.current_energy + total_energy_generated)
        
        # Record new energy level
        self.energy_history.append((time.time(), self.current_energy))
        self.last_cycle_time = time.time()
        
        return total_energy_generated
    
    def _update_forge_state(self) -> None:
        """Update THE FORGE state based on current conditions"""
        # Update cosmic resonance (slowly changes over time)
        resonance_change = (self.qrng.get_random_float() * 2 - 1) * 0.01
        self.cosmic_resonance = max(0.5, min(1.5, self.cosmic_resonance + resonance_change))
        
        # Adjust forge temperature
        if self.cycle_count % 10 == 0:
            temp_change = (self.qrng.get_random_float() * 2 - 1) * 5
            self.forge_temperature = max(50, min(150, self.forge_temperature + temp_change))
        
        # Update stability based on energy level and temperature
        energy_ratio = self.current_energy / self.energy_capacity
        temp_factor = abs(100 - self.forge_temperature) / 50
        
        self.stability = 100.0
        
        # Decrease stability if energy is very low or very high
        if energy_ratio < 0.1 or energy_ratio > 0.9:
            self.stability -= 20.0 * (1 - energy_ratio if energy_ratio < 0.5 else energy_ratio - 0.5) * 2
        
        # Decrease stability if temperature is far from optimal
        self.stability -= temp_factor * 10.0
        
        # Ensure stability stays in valid range
        self.stability = max(0.0, min(100.0, self.stability))
        
        # Update forge status based on conditions
        if self.stability < 30.0:
            self.status = ForgeStatus.CRITICAL
            self._create_alert("FORGE stability critical", "Critical stability level reached")
        elif self.current_energy < self.energy_capacity * 0.2:
            self.status = ForgeStatus.RECHARGING
        elif abs(self.quantum_fluctuation) > 0.15:
            self.status = ForgeStatus.STABILIZING
        else:
            self.status = ForgeStatus.ONLINE
    
    def allocate_energy(self, 
                       layer_id: str, 
                       amount: float) -> Tuple[bool, float]:
        """
        Allocate energy to a blockchain layer.
        
        Args:
            layer_id: ID of the layer to allocate energy to
            amount: Amount of energy to allocate
            
        Returns:
            Tuple of (success, amount_allocated)
        """
        if layer_id not in self.energy_distribution:
            return False, 0.0
        
        # Check if we have enough energy
        if self.current_energy < amount:
            # Allocate what we can
            available = self.current_energy
            self.current_energy = 0
            self.energy_distribution[layer_id] += available
            
            # Update state and record
            self._update_forge_state()
            self.energy_history.append((time.time(), self.current_energy))
            
            return False, available
        
        # Allocate requested energy
        self.current_energy -= amount
        self.energy_distribution[layer_id] += amount
        
        # Update state and record
        self._update_forge_state()
        self.energy_history.append((time.time(), self.current_energy))
        
        return True, amount
    
    def establish_quantum_link(self, 
                              target_system: str,
                              link_strength: float = 10.0) -> str:
        """
        Create a QUANTUM-LINK to another blockchain system.
        
        Args:
            target_system: Name or identifier of the target system
            link_strength: Strength of the quantum link
            
        Returns:
            ID of the new quantum link
        """
        # Generate link ID with quantum entropy
        link_id = str(uuid.uuid4())
        
        # Create the quantum link
        quantum_link = QuantumLink(
            source="THE_FORGE",
            target=target_system,
            strength=link_strength
        )
        
        # Store the link
        self.quantum_links[link_id] = quantum_link
        
        # Energy cost for establishing the link
        link_energy_cost = link_strength * 10.0
        if self.current_energy >= link_energy_cost:
            self.current_energy -= link_energy_cost
            quantum_link.status = "ESTABLISHED"
        else:
            quantum_link.status = "UNSTABLE"
            self._create_alert("QUANTUM-LINK unstable", 
                              f"Insufficient energy for stable link to {target_system}")
        
        return link_id
    
    def get_quantum_link(self, link_id: str) -> Optional[Dict[str, Any]]:
        """
        Get information about a quantum link.
        
        Args:
            link_id: ID of the quantum link
            
        Returns:
            Link information or None if not found
        """
        if link_id not in self.quantum_links:
            return None
        
        return self.quantum_links[link_id].to_dict()
    
    def get_all_quantum_links(self) -> List[Dict[str, Any]]:
        """
        Get information about all quantum links.
        
        Returns:
            List of all quantum links
        """
        return [link.to_dict() for link in self.quantum_links.values()]
    
    def _create_alert(self, 
                     title: str, 
                     message: str, 
                     severity: str = "warning") -> None:
        """Create an alert for THE FORGE"""
        alert = {
            "id": str(uuid.uuid4()),
            "timestamp": time.time(),
            "title": title,
            "message": message,
            "severity": severity
        }
        
        self.alerts.append(alert)
        
        # Limit the number of stored alerts
        if len(self.alerts) > 100:
            self.alerts = self.alerts[-100:]
    
    def get_energy_statistics(self) -> Dict[str, Any]:
        """
        Get statistics about energy generation and usage.
        
        Returns:
            Dictionary of energy statistics
        """
        # Calculate generation rate (units per hour)
        recent_history = self.energy_history[-min(10, len(self.energy_history)):]
        if len(recent_history) >= 2:
            time_diff = recent_history[-1][0] - recent_history[0][0]
            if time_diff > 0:
                energy_diff = recent_history[-1][1] - recent_history[0][1]
                generation_rate = (energy_diff / time_diff) * 3600  # per hour
            else:
                generation_rate = 0.0
        else:
            generation_rate = 0.0
        
        # Calculate distribution percentages
        total_distributed = sum(self.energy_distribution.values())
        distribution_percentages = {
            layer: (amount / total_distributed * 100 if total_distributed > 0 else 0)
            for layer, amount in self.energy_distribution.items()
        }
        
        return {
            "current_energy": self.current_energy,
            "energy_capacity": self.energy_capacity,
            "energy_percentage": (self.current_energy / self.energy_capacity) * 100,
            "forge_temperature": self.forge_temperature,
            "stability": self.stability,
            "cosmic_resonance": self.cosmic_resonance,
            "quantum_fluctuation": self.quantum_fluctuation,
            "cycle_count": self.cycle_count,
            "generation_rate": generation_rate,
            "distribution": distribution_percentages,
            "status": self.status.name
        }
    
    def get_alerts(self, 
                  limit: int = 10, 
                  severity: Optional[str] = None) -> List[Dict[str, Any]]:
        """
        Get recent alerts from THE FORGE.
        
        Args:
            limit: Maximum number of alerts to return
            severity: Filter by severity
            
        Returns:
            List of alerts
        """
        filtered_alerts = self.alerts
        
        if severity:
            filtered_alerts = [a for a in filtered_alerts if a["severity"] == severity]
        
        return sorted(filtered_alerts, key=lambda a: a["timestamp"], reverse=True)[:limit]
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert THE FORGE to a dictionary representation.
        
        Returns:
            Dictionary representation of THE FORGE
        """
        return {
            "forge_id": self.forge_id,
            "energy_capacity": self.energy_capacity,
            "current_energy": self.current_energy,
            "forge_temperature": self.forge_temperature,
            "stability": self.stability,
            "cosmic_resonance": self.cosmic_resonance,
            "quantum_fluctuation": self.quantum_fluctuation,
            "status": self.status.name,
            "creation_time": self.creation_time,
            "last_cycle_time": self.last_cycle_time,
            "cycle_count": self.cycle_count,
            "energy_distribution": self.energy_distribution,
            "quantum_links_count": len(self.quantum_links),
            "statistics": self.get_energy_statistics()
        }


class QuantumLink:
    """
    Represents a quantum link between THE FORGE and another system.
    
    Quantum links enable cross-dimensional connections through QUANTUM-LINK
    Technology, allowing secure communication and energy transfer between
    different blockchain systems.
    """
    
    def __init__(self, 
                 source: str,
                 target: str,
                 strength: float = 10.0):
        """
        Initialize a new quantum link.
        
        Args:
            source: Source of the quantum link
            target: Target of the quantum link
            strength: Strength of the quantum link
        """
        self.link_id = str(uuid.uuid4())
        self.source = source
        self.target = target
        self.strength = strength
        self.status = "INITIALIZING"  # INITIALIZING, ESTABLISHED, UNSTABLE, BROKEN
        self.established_at = time.time()
        self.last_activity = self.established_at
        self.stability = 100.0  # Percentage
        self.bandwidth = strength * 10.0  # Data transfer capacity
        self.energy_flow = 0.0  # Current energy flow through link
        self.total_transferred = 0.0  # Total energy transferred
        self.qrng = QuantumRandomNumberGenerator()
    
    def transfer_energy(self, amount: float) -> float:
        """
        Transfer energy through the quantum link.
        
        Args:
            amount: Amount of energy to transfer
            
        Returns:
            Amount actually transferred
        """
        # Calculate maximum transfer capacity based on link properties
        max_transfer = self.bandwidth * (self.stability / 100.0)
        
        # Limit transfer amount
        actual_transfer = min(amount, max_transfer)
        
        # Update link properties
        self.energy_flow = actual_transfer
        self.total_transferred += actual_transfer
        self.last_activity = time.time()
        
        # Stability decreases slightly with each transfer
        stability_decrease = (actual_transfer / max_transfer) * 0.1
        self.stability = max(0.0, self.stability - stability_decrease)
        
        # Update status based on stability
        if self.stability < 20.0:
            self.status = "BROKEN"
        elif self.stability < 50.0:
            self.status = "UNSTABLE"
        else:
            self.status = "ESTABLISHED"
        
        return actual_transfer
    
    def regenerate_stability(self) -> None:
        """Regenerate the stability of the quantum link over time"""
        # Links naturally regenerate stability over time
        time_since_activity = time.time() - self.last_activity
        if time_since_activity > 10.0:  # After 10 seconds of inactivity
            # Regenerate 1% stability per second of inactivity
            regeneration = (time_since_activity - 10.0) * 0.01
            self.stability = min(100.0, self.stability + regeneration)
            
            # Update status based on new stability
            if self.stability >= 50.0 and self.status != "ESTABLISHED":
                self.status = "ESTABLISHED"
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert the quantum link to a dictionary representation.
        
        Returns:
            Dictionary representation of the quantum link
        """
        # Regenerate stability before returning status
        self.regenerate_stability()
        
        return {
            "link_id": self.link_id,
            "source": self.source,
            "target": self.target,
            "strength": self.strength,
            "status": self.status,
            "established_at": self.established_at,
            "last_activity": self.last_activity,
            "stability": self.stability,
            "bandwidth": self.bandwidth,
            "energy_flow": self.energy_flow,
            "total_transferred": self.total_transferred,
            "age": time.time() - self.established_at
        }


class EnergyMonitor:
    """
    Monitors and manages energy distribution from THE FORGE.
    
    The energy monitor tracks energy usage across all layers of the blockchain
    architecture, optimizes distribution, and alerts on potential issues.
    """
    
    def __init__(self, quantum_forge: QuantumForge):
        """
        Initialize a new energy monitor.
        
        Args:
            quantum_forge: The quantum forge to monitor
        """
        self.monitor_id = str(uuid.uuid4())
        self.quantum_forge = quantum_forge
        self.energy_thresholds = {
            "warning": 0.2,  # 20% of capacity
            "critical": 0.1,  # 10% of capacity
            "emergency": 0.05  # 5% of capacity
        }
        self.layer_allocations = {
            "genesischain": 0.5,  # 50% to GenesisChain
            "nexuslayer": 0.2,    # 20% to NexusLayer
            "dreamchain": 0.3     # 30% to DreamChain
        }
        self.monitoring_interval = 60.0  # seconds
        self.last_monitoring = time.time()
        self.monitoring_history = []
        self.alerts = []
    
    def monitor_energy_levels(self) -> Dict[str, Any]:
        """
        Monitor energy levels and distribution.
        
        Returns:
            Monitoring results
        """
        # Get current forge status
        forge_stats = self.quantum_forge.get_energy_statistics()
        energy_level = forge_stats["current_energy"]
        energy_capacity = forge_stats["energy_capacity"]
        energy_ratio = energy_level / energy_capacity
        
        # Check thresholds and create alerts if needed
        if energy_ratio <= self.energy_thresholds["emergency"]:
            self._create_alert(
                "EMERGENCY: Critical Energy Levels",
                f"THE FORGE energy at {energy_ratio*100:.1f}% of capacity",
                "emergency"
            )
        elif energy_ratio <= self.energy_thresholds["critical"]:
            self._create_alert(
                "CRITICAL: Low Energy Levels",
                f"THE FORGE energy at {energy_ratio*100:.1f}% of capacity",
                "critical"
            )
        elif energy_ratio <= self.energy_thresholds["warning"]:
            self._create_alert(
                "WARNING: Energy Levels Decreasing",
                f"THE FORGE energy at {energy_ratio*100:.1f}% of capacity",
                "warning"
            )
        
        # Record monitoring data
        monitoring_data = {
            "timestamp": time.time(),
            "energy_level": energy_level,
            "energy_capacity": energy_capacity,
            "energy_ratio": energy_ratio,
            "forge_status": forge_stats["status"],
            "distribution": self.quantum_forge.energy_distribution.copy()
        }
        
        self.monitoring_history.append(monitoring_data)
        self.last_monitoring = time.time()
        
        # Limit history size
        if len(self.monitoring_history) > 1000:
            self.monitoring_history = self.monitoring_history[-1000:]
        
        return monitoring_data
    
    def optimize_energy_distribution(self) -> Dict[str, float]:
        """
        Optimize energy distribution across layers.
        
        Returns:
            New distribution percentages
        """
        # Get current forge stats
        forge_stats = self.quantum_forge.get_energy_statistics()
        
        # Calculate available energy for redistribution
        available_energy = self.quantum_forge.current_energy * 0.1  # Use 10% for redistribution
        
        # Distribute according to layer allocations
        new_distribution = {}
        for layer, percentage in self.layer_allocations.items():
            allocation = available_energy * percentage
            success, allocated = self.quantum_forge.allocate_energy(layer, allocation)
            new_distribution[layer] = allocated
            
            # Log allocation
            if not success:
                self._create_alert(
                    "Energy Allocation Limited",
                    f"Could only allocate {allocated} energy to {layer}",
                    "info"
                )
        
        return new_distribution
    
    def _create_alert(self, 
                     title: str, 
                     message: str, 
                     severity: str = "info") -> None:
        """Create an alert from the energy monitor"""
        alert = {
            "id": str(uuid.uuid4()),
            "timestamp": time.time(),
            "title": title,
            "message": message,
            "severity": severity,
            "source": "energy_monitor"
        }
        
        self.alerts.append(alert)
        
        # Limit alert history size
        if len(self.alerts) > 100:
            self.alerts = self.alerts[-100:]
    
    def get_monitoring_history(self, 
                              limit: int = 100) -> List[Dict[str, Any]]:
        """
        Get monitoring history.
        
        Args:
            limit: Maximum number of records to return
            
        Returns:
            Recent monitoring history
        """
        return sorted(self.monitoring_history, 
                     key=lambda x: x["timestamp"], 
                     reverse=True)[:limit]
    
    def get_alerts(self, 
                  limit: int = 10, 
                  severity: Optional[str] = None) -> List[Dict[str, Any]]:
        """
        Get recent alerts from the energy monitor.
        
        Args:
            limit: Maximum number of alerts to return
            severity: Filter by severity
            
        Returns:
            List of alerts
        """
        filtered_alerts = self.alerts
        
        if severity:
            filtered_alerts = [a for a in filtered_alerts if a["severity"] == severity]
        
        return sorted(filtered_alerts, key=lambda a: a["timestamp"], reverse=True)[:limit]
    
    def get_layer_recommendations(self) -> Dict[str, Any]:
        """
        Get energy usage recommendations for each layer.
        
        Returns:
            Recommendations for energy usage
        """
        # Current forge stats
        forge_stats = self.quantum_forge.get_energy_statistics()
        
        # Calculate recommendations based on current status
        recommendations = {}
        
        if forge_stats["energy_percentage"] < 20.0:
            # Low energy - conserve in all layers
            recommendations = {
                "genesischain": {
                    "action": "reduce",
                    "target": "50%",
                    "reason": "THE FORGE energy levels critical"
                },
                "nexuslayer": {
                    "action": "reduce",
                    "target": "70%",
                    "reason": "THE FORGE energy levels critical"
                },
                "dreamchain": {
                    "action": "reduce",
                    "target": "90%",
                    "reason": "THE FORGE energy levels critical"
                }
            }
        elif forge_stats["stability"] < 50.0:
            # Stability issues - focus on critical systems
            recommendations = {
                "genesischain": {
                    "action": "maintain",
                    "target": "100%",
                    "reason": "Critical security layer"
                },
                "nexuslayer": {
                    "action": "reduce",
                    "target": "50%",
                    "reason": "THE FORGE stability issues"
                },
                "dreamchain": {
                    "action": "reduce",
                    "target": "30%",
                    "reason": "THE FORGE stability issues"
                }
            }
        else:
            # Normal operation - balanced distribution
            recommendations = {
                "genesischain": {
                    "action": "maintain",
                    "target": "100%",
                    "reason": "Normal operation"
                },
                "nexuslayer": {
                    "action": "maintain",
                    "target": "100%",
                    "reason": "Normal operation"
                },
                "dreamchain": {
                    "action": "maintain",
                    "target": "100%",
                    "reason": "Normal operation"
                }
            }
        
        return recommendations
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert the energy monitor to a dictionary representation.
        
        Returns:
            Dictionary representation of the energy monitor
        """
        return {
            "monitor_id": self.monitor_id,
            "energy_thresholds": self.energy_thresholds,
            "layer_allocations": self.layer_allocations,
            "monitoring_interval": self.monitoring_interval,
            "last_monitoring": self.last_monitoring,
            "alert_count": len(self.alerts),
            "history_count": len(self.monitoring_history),
            "recent_monitoring": self.get_monitoring_history(5),
            "recommendations": self.get_layer_recommendations()
        }